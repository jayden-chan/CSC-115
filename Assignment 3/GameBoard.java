/**
 * GameBoard.java
 * @author Mike Zastre
 *
 * For use with Assignment #3, UVic CSC 115 (Spring 2018)
 * University of Victoria.
 */

import java.util.*;

/**
 * GameBoard creates a representation of the word-search game
 * board. Some of the methods to be completed by students
 * for assignment #3 can be found here.
 */
public class GameBoard {
    public static final int NUM_ROWS = 4;
    public static final int NUM_COLS = 4;

    private static String[] GAME_PIECES = {
        "RIFOBX", "IFEHEY", "DENOWS", "UTOKND",
        "HMSRAO", "LUPETS", "ACITOA", "YLGKUE",
        "QBMJOA", "EHISPN", "VETIGN", "BALIYT",
        "EZAVND", "RALESC", "UWILRG", "PACEMD"
    };

    private char[][] board;
    private boolean[][] visited;


    /**
     * Accepts a string-array representation of the game
     * board, and initializes the board to this value.
     * @param start A one-dimensional array of strings. Each row
     * corresponds to a row in the gameboard. If there are
     * too few characters in a row for the board, or too few
     * rows for the whole board, then the '.' character is
     * substituted for that game board position.
     */
    public GameBoard(String[] start) {
        this.board = new char[NUM_ROWS][NUM_COLS];

        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLS; col++) {
                this.board[row][col] = (
                    (row < start.length && col < start[row].length()) ?
                     start[row].toUpperCase().charAt(col) :
                     '.'
                 );
            }
        }

        this.visited = new boolean[NUM_ROWS][NUM_COLS];
    }


    /**
     * Creates a random game board based on the random seed
     * value given as a parameter and the game-board
     * strings at the start of the class.
     *
     * The seed provided is used to initialize the random-number
     * generator -- whenever the same seed is used for such an
     * initialization, the same sequence of random numbers will
     * be generated by that random object.
     *
     * Creating the board consists of a few steps:
     *
     * (a) The static string array GAME_PIECES consists of 16
     *     strings each with six letters. These 16 strings are
     *     first randomly shuffled amongst themselves (i.e., the
     *     content of each string is not modified, but the position
     *     of that string in GAME_PIECES may be changed).
     *
     * (b) After this first shuffle, the content within each string
     *     in GAME_PIECES is randomly shuffled.
     *
     * (c) With (a) and (b) done, we can now store a letter in
     *     each of the gameboard's letter squares (i.e., each
     *     square is actually a location within a 2D char array).
     *     The last set of nested loops in this method performs
     *     such a step, storing the first character of each string
     *     in GAME_PIECES into positions of the 2D char array
     *     (an instance variable) named "board".
     * @param seed The value to initialized the Random object
     * used to create the game board.
     */
    public GameBoard(long seed) {
        this.board = new char[NUM_ROWS][NUM_COLS];

        Random r = new Random(seed);
        shuffle(GAME_PIECES, r);

        for (int i = 0; i < GAME_PIECES.length; i++) {
            Character rowPieces[] = new Character[GAME_PIECES[i].length()];
            for (int pos = 0; pos < GAME_PIECES[i].length(); pos++) {
                rowPieces[pos] = GAME_PIECES[i].charAt(pos);
            }
            shuffle(rowPieces, r);
            GAME_PIECES[i] = "";
            for (Character c : rowPieces) {
                GAME_PIECES[i] += c;
            }
        }

        int count = 0;
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLS; col++) {
                this.board[row][col] = GAME_PIECES[count].charAt(0);
                count++;
            }
        }

        this.visited = new boolean[NUM_ROWS][NUM_COLS];
    }


    /**
     * An implementation of the Fisher-Yates random shuffle,
     * also known as the Knuth shuffle. For more algorithm
     * details visit. For more details see http://bit.ly/1q6jhRh
     *
     * @param array A collection of values to be shuffled. The
     * values in this array will be moved within the array, and
     * this works given the nature of object references in Java.
     * @param r An already-created instance of Random which
     * is used as a source of random integers as needed by the
     * algorithm.
     */
    private void shuffle(Object array[], Random r) {
        for (int i = array.length - 1; i > 0; i--) {
            int index = r.nextInt(i + 1);
            Object temp = array[index];
            array[index] = array[i];
            array[i] = temp;
        }
    }


    /**
     * Creates a printable representation of the gameboard.
     * For examples of output from this method, please read
     * the assignment description.
     * @return Single string with representation of gameboard.
     */
    public String toString() {
        String result = "     0 1 2 3\n"
                      + "     -------\n";

        for (int row = 0; row < NUM_ROWS; row++) {
            result += "  " + row + ":";
            for (int col = 0; col < NUM_COLS; col++) {
                result += " " + board[row][col];
            }
            result += "\n";
        }

        return result;
    }


    /**
     * Given the state of the given GameBoard instance, determine
     * whether or not the given word is on the board.
     * @param word The word for which a search of the board
     * must be performed (i.e., recursive backtracking).
     * @return A string with the letter-square path through the
     * board the, when followed, will equal the letters in the
     * word. If the word *cannot* be found, then null is
     * returned.
     */
    public String isWord(String word) {
        resetVisited();
        word = word.toUpperCase();
        Stack<String> path = new Stack<>();
        boolean hasPath = false;

        for(int i = 0; i < NUM_ROWS; i++) {
            if(hasPath) break;
            for(int j = 0; j < NUM_COLS; j++) {
                if(hasPath) break;
                if(board[i][j] == word.charAt(0)) {
                    // System.out.println("Found start at " + i + ", " + j);
                    hasPath = findPath(word, path, i, j);
                }
            }
        }

        if(!hasPath) {
            return null;
        }

        StringBuilder sb = new StringBuilder();
        sb.append("[");
        while(!path.empty()) {
            sb.append(path.pop());
            if(!path.empty()) {
                sb.append(", ");
            }
        }

        sb.append("]");
        return sb.toString();
    }


    /**
     * Given the GameBoard instance's letter square, find
     * path/sequence the spells out wordToFind starting from
     * square (row, col), with the pathSoFar including this
     * current (row, col) if a path can be found. This is
     * meant to be a recursive method, therefore will require
     * one or more base cases and one or more recursive
     * cases.
     *
     * @param wordtoFind The word for which a sequence must
     * be found on the board. Note could possible be a single
     * character (which should be a base case). Also note
     * that sequence of calls to findPath should occur with
     * short and short strings in wordToFind.
     * @param pathSoFar The stack is use to keep track of
     * (row, col) lettersquares on the path. Any call of this
     * method should directly perform at most one push and
     * at most one pop.
     * @param row Row index of square from which to start
     * looking for a sequence. (The assumption is that this
     * function is only ever called if the first letter in
     * word corrsponds to the (row, col) lettersequare).
     * @param col Column index of square from which to
     * start looking for a sequence.
     * @return true if a sequence can be found, false
     * otherwise.
     */
    public boolean findPath(String wordToFind,
                             Stack<String> pathSoFar,
                             int row, int col)
    {
        /* Well, this is definitely some of the messiest code
         * I've ever written. I don't really have time to
         * optimize it a whole lot though, but I did try
         * to put as many comments as possible so it's
         * a little easier to understand.
         */

        /* Base case for the recursion. If we have made it
         * to the last letter of the string we must be done
         * so return true.
         */
        if(wordToFind.length() == 1) {
            pathSoFar.push("(" + row + ", " + col + ")");
            return true;
        }

        // Mark the current node as visited
        visited[row][col] = true;

        // Store the possible paths that we might be able to take
        ArrayList<int[]> possiblePaths = checkVacinity(row, col, wordToFind.charAt(1));


        // If there are possible paths, go through each one to
        // see if it leads somewhere.
        for(int[] p : possiblePaths) {
            // If we have already visited a point do not try it
            if(visited[p[0]][p[1]]) {
                continue;
            }

            /* Call the function recursively for the same word minus the
             * first letter. This is how we reach the base case. If this
             * part returns false, it means the current path we're
             * testing didn't work, so we will backtrack and move on to
             * the next path in the list (using the loop).
             */
            if(findPath(wordToFind.substring(1), pathSoFar, p[0], p[1])) {
                pathSoFar.push("(" + row + ", " + col + ")");
                return true;
            }
        }

        /* If we reach this point in the program it means that
         * we tried all the paths and none worked, or that there
         * were no paths found. Either way we must return false
         * in this case.
         */
        return false;
    }

    /**
     * Checks the all of the squares surrounding [row, col] to see if
     * it contains the char 'lookingFor'.
     * @param row The y coordinate of the position to search around.
     * @param col The x coordinate of the position to search around.
     * @param lookingFor The char to look for.
     * @return A list of all the points that contain the char.
     */
    public ArrayList<int[]> checkVacinity(int row, int col, char lookingFor) {
        // Create the list of points to return.
        ArrayList<int[]> list = new ArrayList<>();

        // Iterate through the surrounding points
        for(int i = row-1; i < row+2; i++) {
            // If the point is outside the board just skip it
            if(i < 0 || i >= NUM_ROWS) continue;

            for(int j = col-1; j < col+2; j++) {
                // If the point is outside the board just skip it
                if(j < 0 || j >= NUM_COLS) continue;

                // If the point matches what we are looking for and
                // isn't the starting point, add it to the list.
                if(board[i][j] == lookingFor && !(i == row && j == col)) {
                    // System.out.println("Added: " + i + ", " + j);
                    list.add(new int[]{i, j});
                }
            }
        }

        // Return the list of points that we found.
        return list;
    }

    /**
     * Resets all of the points on the board
     * to ensure that if the algorithm is run
     * again, it still works.
     */
    private void resetVisited() {
        for(int i = 0; i < NUM_ROWS; i++) {
            for(int j = 0; j < NUM_COLS; j++) {
                visited[i][j] = false;
            }
        }
    }


    /**
     * Creates a few GameBoard instances and causes their
     * contents to be printed. This method should be used for
     * tests written by the student as they develop their
     * solution.
     */
    static public void main(String[] args) {
        String testBoard[] = {"HEAP", "PLTO", "HKSM", "ASPA"};
        GameBoard test01 = new GameBoard(testBoard);
        System.out.println(test01);
        System.out.println(test01.isWord("HEAP"));
        System.out.println(test01.isWord("heap"));
        System.out.println(test01.isWord("TSS"));
        System.out.println(test01.isWord("TO"));
        System.out.println(test01.isWord("PLEAT"));
        System.out.println(test01.isWord("POMP"));
        System.out.println(test01.isWord("ASK"));
        System.out.println(test01.isWord("HEALTH"));
    }
}
